<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Сверхдлинные файловые пути</title>
</head>
<body>
<p>Большинство считает, что в unix длина полного пути к файлу ограничена
некоторым количеством символов — 1024 в большинстве реализаций, включая
ограничительный NUL (то есть 1023 содержательных символа).
Все выглядит хорошо: более длинные пути не принимаются,
пути короче этого предела работают всегда нормально. Правду же — что реальная
длина пути практически неограниченна и ее предел определяется размерами
файловой системы — знают достаточно немногие.</p>

<p>bash не даст вам провести следующий простой эксперимент. Стандартный sh
из FreeBSD — даст. Делаем:</p>

<pre>
while :; do mkdir $N; cd $N; echo $N; N=`expr $N+1`; done
</pre>

<p>Я дошел до 979. Встроенный pwd этого шелла дал ответ, длина которого равна
3817 — он следил за перемещениями и записал их всех. (bash тоже мог
следить, но он глупее в этом вопросе — путь больше стандартных 1024 символов
его сводит с ума, и работа цикла останавливается.)
/bin/pwd не смог определить путь в этом случае, выдав
невразумительную диагностику — getcwd() отказал, а /bin/pwd сам не справится.
rm -rf на верхний каталог этого безобразия (версия rm из FreeBSD 4.5-release)
сумел удалить каталог; в 3.x версии и раньше — не умел. Даже find из
той же версии FreeBSD разобрался правильно:
`find 1 -print -delete -depth' стерло все безобразие за один заход,
правильно показав пути. Это связано с тем, что длина буфера подсистемы fts
сейчас равна 64K; тем не менее, она все равно ограничена, и более длинные
пути могут привести к отказу find, rm и прочих утилит, использующих fts.</p>

<p>Если у вас нет шелла, который не сойдет с ума оказавшись в слишком
глубоком каталоге, можно программу написать на Си  — она создаст
каталог произвольной глубины, а разбираться с этим придется уже извне.;))</p>

<p>Далее. Делаем маленькую программку:</p>

<pre>
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;err.h&gt;
int main() {
   int i;
   for (i = 1; i &lt;= 2048; i++) {
      char s[100];
      snprintf(s, sizeof s, "d-%d", i);
      if(mkdir(s, 0755) &lt; 0) { err(1, "mkdir()"); }
      if(chdir(s) &lt; 0) { err(1, "chdir()"); }
   }
   system("/usr/local/bin/bash");
   return 0;
}
</pre>

<p>Запускаем. Находились в /usr/tmp. Что говорит bash?</p>

<pre>
14:22:14:netch@iv:/usr/tmp&gt;./s1
shell-init: could not get current directory: getcwd: cannot access parent directories: Result too large
14:22:21:netch@iv:/usr/tmp&gt;
</pre>

<p>Первый prompt баша — до запуска программы, второй — уже из того баша,
который запущен из s1. Не сумев получить текущий путь, он воспользовался
значением переменной PWD из окружения. Это можно подтвердить тестом:</p>

<pre>
14:23:41:netch@iv:/usr/tmp&gt;PWD=/var ./s1
shell-init: could not get current directory: getcwd: cannot access parent directories: Result too large
14:23:53:netch@iv:/var&gt;/bin/pwd
pwd: .: No such file or directory
14:23:59:netch@iv:/var&gt;pwd
pwd: could not get current directory: getcwd: cannot access parent directories: Result too large
14:24:00:netch@iv:/var&gt;
</pre>

<p>То есть, bash продолжает сходить с ума. /bin/pwd — тоже.</p>

<p>Меняем bash на sh...</p>

<pre>
14:24:42:netch@iv:/usr/tmp&gt;./s1
sh: cannot determine working directory
$ pwd
pwd: getcwd() failed: Result too large
$
</pre>

<p>Этот хоть не стал показывать фиктивный путь — за что ему большое спасибо.</p>

<p>Везде в тестах bash был версии 2.05a — самой последней.</p>

<p>Оба варианта создания "сверхглубокого" каталога — на шелле и на Си —
показывают принцип создания: на каждой итерации используется короткий
отрезок пути, который сам короче чем предельная длина в 1023 содержательных
символа, и все пути относительны — отсчитываются от текущего каталога.
Без использования текущего каталога (которому ядро совершенно не мешает
быть сколь угодно глубоко) ничего бы не получилось.</p>
<hr>
<p>(C) 2002 Valentin Nechayev. All rights reserved.<br>
Разрешается полное или частичное копирование, цитирование.
При полном или частичном копировании ссылка на оригинал
обязательна.</p>
<p>$Id: ulpaths.html,v 1.3 2002/11/16 12:15:28 netch Exp $</p>
</body>
</html>
